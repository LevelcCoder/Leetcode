//自己不会剪枝，一直过不了
class Solution {
public: 
    int n = 0;
    int edge_len = 0;
    vector<int> matchsticks;
    int edges_visited[20] = {0};
    bool makesquare(vector<int>& matchsticks) {
        this->matchsticks = matchsticks;
        if(matchsticks.size()<4){
            return false;
        }
        n = matchsticks.size();
        edge_len = accumulate(matchsticks.begin(),matchsticks.end(),0);
        if(edge_len%4){
            return false;
        }
        else edge_len/=4;
        //sort(matchsticks.begin(),matchsticks.end(),greater<int>());
        int left = 0;
        int right = n-1;
        if(matchsticks[right]>edge_len) return false;
       
        return dfs(0,edge_len,0);
    }
    
    bool dfs(int edge_cnt,int len,int start){
        if(edge_cnt>=3) return true;
        if(len==0){
            return dfs(edge_cnt+1,edge_len,0);
        }
        for(int i=start;i<n;i++){
            if(edges_visited[i]==0&&len>=matchsticks[i]){
                edges_visited[i]=1;
                    
                if(dfs(edge_cnt,len-matchsticks[i],i+1)) return true;//i+1很重要的剪枝
                    //else if(len==edge_len) return false;
                
                edges_visited[i]=0;
            }
        }
        return false;
    }
};

//官方动态规划加状态压缩
class Solution {
public:
    bool makesquare(vector<int>& matchsticks) {
        int totalLen = accumulate(matchsticks.begin(), matchsticks.end(), 0);
        if (totalLen % 4 != 0) {
            return false;
        }
        int len = totalLen / 4, n = matchsticks.size();
        vector<int> dp(1 << n, -1);
        dp[0] = 0;
        for (int s = 1; s < (1 << n); s++) {
            for (int k = 0; k < n; k++) {
                if ((s & (1 << k)) == 0) {
                    continue;
                }
                int s1 = s & ~(1 << k);
                if (dp[s1] >= 0 && dp[s1] + matchsticks[k] <= len) {
                    dp[s] = (dp[s1] + matchsticks[k]) % len;
                    break;
                }
            }
        }
        return dp[(1 << n) - 1] == 0;
    }
};

