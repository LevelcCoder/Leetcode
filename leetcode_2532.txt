class Solution {
public:
    using PII = pair<int,int>;
    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
        auto wait_priority_cmp = [&](int x, int y) {
            int time_x = time[x][0] + time[x][2];
            int time_y = time[y][0] + time[y][2];
            return time_x != time_y ? time_x < time_y : x < y;
        };

        priority_queue<int, vector<int>, decltype(wait_priority_cmp)> wait_left(wait_priority_cmp), wait_right(wait_priority_cmp);
        priority_queue<PII, vector<PII>, greater<PII>> work_left, work_right;

        int remain = n;
        int cur_time = 0;
        for(int i=0;i<k;i++) wait_left.push(i);
        while(remain>0||!work_right.empty()||!wait_right.empty()){//因为是在拿走（正在取）时remain--，故需要在右岸工作的优先队列和在右岸等待的优先队列都为空再能得到最后一个工人返回左岸的cur_time
            while(!work_right.empty()&&work_right.top().first<=cur_time){
                int idx = work_right.top().second;
                work_right.pop();
                wait_right.push(idx);
            }
            while(!work_left.empty()&&work_left.top().first<=cur_time){
                int idx = work_left.top().second;
                work_left.pop();
                wait_left.push(idx);
            }
            if(!wait_right.empty()){
                int idx = wait_right.top();
                cur_time += time[idx][2];
                work_left.push(pair(cur_time+time[idx][3],idx));
                wait_right.pop();
                
            }
            else if(!wait_left.empty()&&remain>0){
                int idx = wait_left.top();
                cur_time += time[idx][0];
                work_right.push(pair(cur_time+time[idx][1],idx));//已经拿了最后一个箱子
                wait_left.pop();
                remain--;
               
            }
            else{
                if(!work_right.empty()&&!work_left.empty())
                cur_time = min(work_left.top().first,work_right.top().first);
                else if(!work_right.empty()) cur_time = work_right.top().first;
                else if(!work_left.empty()) cur_time = work_left.top().first;
            }
            
            
        }
        return cur_time;
    }
};